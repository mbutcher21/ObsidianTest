import * as Models from './models';
import * as Parameters from './parameters';
import { Callback } from '../callback';
import { Client } from '../clients';
import { Pagination } from '../pagination';
export declare class User {
    private client;
    constructor(client: Client);
    /** Get information about a user identified by either user key or username. */
    getUser<T = Models.User>(parameters: Parameters.GetUser | undefined, callback: Callback<T>): Promise<void>;
    /** Get information about a user identified by either user key or username. */
    getUser<T = Models.User>(parameters?: Parameters.GetUser, callback?: never): Promise<T>;
    /** Get information about the how anonymous is represented in confluence */
    getAnonymousUser<T = Models.UserAnonymous>(callback: Callback<T>): Promise<void>;
    /** Get information about the how anonymous is represented in confluence */
    getAnonymousUser<T = Models.UserAnonymous>(callback?: never): Promise<T>;
    /** Get information about the current logged-in user. */
    getCurrentUser<T = Models.User>(parameters: Parameters.GetCurrentUser | undefined, callback: Callback<T>): Promise<void>;
    /** Get information about the current logged-in user. */
    getCurrentUser<T = Models.User>(parameters?: Parameters.GetCurrentUser, callback?: never): Promise<T>;
    /** Get a paginated collection of groups that the given user is a member of */
    getGroupMembershipsForUser<T = Pagination<Models.Group>>(parameters: Parameters.GetGroups | undefined, callback: Callback<T>): Promise<void>;
    /** Get a paginated collection of groups that the given user is a member of */
    getGroupMembershipsForUser<T = Pagination<Models.Group>>(parameters?: Parameters.GetGroups, callback?: never): Promise<T>;
    /**
     * Get information about whether a user is watching a specified content.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    getContentWatchStatus<T = Models.UserWatch>(parameters: Parameters.GetContentWatchStatus, callback: Callback<T>): Promise<void>;
    /**
     * Get information about whether a user is watching a specified content.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    getContentWatchStatus<T = Models.UserWatch>(parameters: Parameters.GetContentWatchStatus, callback?: never): Promise<T>;
    /**
     * Create a new watcher for the given user and content id.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    addContentWatcher<T = void>(parameters: Parameters.AddContentWatcher, callback: Callback<T>): Promise<void>;
    /**
     * Create a new watcher for the given user and content id.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    addContentWatcher<T = void>(parameters: Parameters.AddContentWatcher, callback?: never): Promise<T>;
    /**
     * Delete an existing watcher for the given user and content id.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    removeContentWatcher<T = void>(parameters: Parameters.RemoveContentWatcher, callback: Callback<T>): Promise<void>;
    /**
     * Delete an existing watcher for the given user and content id.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    removeContentWatcher<T = void>(parameters: Parameters.RemoveContentWatcher, callback?: never): Promise<T>;
    /**
     * Get information about whether a user is watching a specified space.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    isWatchingSpace<T = Models.UserWatch>(parameters: Parameters.IsWatchingSpace, callback: Callback<T>): Promise<void>;
    /**
     * Get information about whether a user is watching a specified space.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    isWatchingSpace<T = Models.UserWatch>(parameters: Parameters.IsWatchingSpace, callback?: never): Promise<T>;
    /**
     * Create a new watcher for the given user and space key.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    addSpaceWatch<T = void>(parameters: Parameters.AddSpaceWatch, callback: Callback<T>): Promise<void>;
    /**
     * Create a new watcher for the given user and space key.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    addSpaceWatch<T = void>(parameters: Parameters.AddSpaceWatch, callback?: never): Promise<T>;
    /**
     * Delete an existing watcher for the given user and space key.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    removeSpaceWatch<T = void>(parameters: Parameters.RemoveSpaceWatch, callback: Callback<T>): Promise<void>;
    /**
     * Delete an existing watcher for the given user and space key.
     *
     * User is optional. If not specified, currently logged-in user will be used. Otherwise, it can be specified by either
     * user key or username. When a user is specified and is different from the logged-in user, the logged-in user needs
     * to be a Confluence administrator.
     */
    removeSpaceWatch<T = void>(parameters: Parameters.RemoveSpaceWatch, callback?: never): Promise<T>;
}
